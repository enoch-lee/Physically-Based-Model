<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name='viewport' content='width=device-width'/>
    <title>Flock</title>
    <style>
        body {
            font-family: Monospace;
            background-color: #000;
            color: #000;
            margin: 0px;
            overflow: hidden;
        }
        #info {
            position: absolute;
            padding: 10px;
            width: 100%;
            text-align: center;
            font-size: 3em;
        }
    </style>
</head>
<body>
<!--<div id = 'info'></div>-->
<div id = 'canvas'></div>
<script src="js/three.min.js"></script>
<script src="js/Bird.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/stats.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.5/dat.gui.min.js"></script>

<script>
    'use strict';

    const NEIGHBOR_RADIUS = 50;
    const MAX_STEER_FORCE = 0.1;
    const DESIRED_SEPARATION = 20;
    const MAX_SPEED = 4;
    const WALL_WIDTH = 500, WALL_HEIGHT = 500, WALL_DEPTH = 500;

    let Boid = function () {
        this.velocity = new THREE.Vector3();
        this.position = new THREE.Vector3();
    };

    Boid.prototype.move = function (boids, obj, predator, timeStep = 1) {

        let acceleration = new THREE.Vector3();

        let vector = new THREE.Vector3();
        vector.set(-WALL_WIDTH / 2, this.position.y, this.position.z);
        vector = this.avoid(vector);
        vector.multiplyScalar(2);
        acceleration.add(vector);
        vector.set(WALL_WIDTH / 2, this.position.y, this.position.z);
        vector = this.avoid(vector);
        vector.multiplyScalar(2);
        acceleration.add(vector);
        vector.set(this.position.x, -WALL_HEIGHT / 2, this.position.z);
        vector = this.avoid(vector);
        vector.multiplyScalar(2);
        acceleration.add(vector);
        vector.set(this.position.x, WALL_HEIGHT/ 2, this.position.z);
        vector = this.avoid(vector);
        vector.multiplyScalar(2);
        acceleration.add(vector);
        vector.set(this.position.x, this.position.y, -WALL_DEPTH / 2);
        vector = this.avoid(vector);
        vector.multiplyScalar(2);
        acceleration.add(vector);
        vector.set(this.position.x, this.position.y, WALL_DEPTH / 2);
        vector = this.avoid(vector);
        vector.multiplyScalar(2);
        acceleration.add(vector);

        //predator.velocity.add(acceleration);

        vector = this.avoid(predator);
        acceleration.add(vector);

        acceleration.add(this.flock(boids));
        acceleration.add(this.avoidObj(obj));
        this.velocity.add(acceleration);

        let len = this.velocity.length();
        if(len > MAX_SPEED){
            this.velocity.divideScalar( len / MAX_SPEED );
        }
        this.position.add(this.velocity.multiplyScalar(timeStep));
    };

    Boid.prototype.flock = function (boids) {
        let acceleration = new THREE.Vector3();
        acceleration.add(this.cohesion(boids));
        acceleration.add(this.alignment(boids));
        acceleration.add(this.separation(boids));

        return acceleration;
    };

    Boid.prototype.cohesion = function (boids) {
        let count = 0;
        let pSum = new THREE.Vector3();
        let steer = new THREE.Vector3();

        for (let i = 0; i < boids.length; ++i) {
            let boid = boids[i];
            let dist = boid.position.distanceTo(boid.position);
            if (dist > 0 && dist < NEIGHBOR_RADIUS) {
                pSum.add(boid.position);
                count++;
            }
        }

        if (count > 0) {
            pSum.divideScalar(count);
        }

        steer.subVectors(pSum, this.position);

        let len = steer.length();
        if (len > 0.01) {
            steer.divideScalar(len / 0.05);
        }

        return steer;
    };

    Boid.prototype.alignment = function (boids) {
        let count = 0;
        let vSum = new THREE.Vector3();

        for (let i = 0; i < boids.length; ++i) {
            let boid = boids[i];
            let dist = this.position.distanceTo(boid.position);
            if (dist > 0 && dist < NEIGHBOR_RADIUS) {
                vSum.add(boid.velocity);
                count++;
            }
        }

        if (count > 0) {
            vSum.divideScalar(count);
            let len = vSum.length();
            if (len > MAX_STEER_FORCE) {
                vSum.divideScalar(len / MAX_STEER_FORCE);
            }
        }
        return vSum;
    };

    Boid.prototype.separation = function (boids) {
        let pSum = new THREE.Vector3();
        let repulse = new THREE.Vector3();

        for (let i = 0; i < boids.length; ++i) {
            let boid = boids[i];
            let dist = this.position.distanceTo(boid.position);
            if (dist > 0 && dist < DESIRED_SEPARATION) {
                pSum.add(repulse.subVectors(this.position, boid.position).normalize().divideScalar(dist));
            }
        }

//        let len = pSum.length();
//        if (len > MAX_STEER_FORCE) {
//            pSum.divideScalar(len / MAX_STEER_FORCE);
//        }

        return pSum;
    };

    Boid.prototype.avoid = function (target) {
        let steer = new THREE.Vector3();
        steer.copy(this.position);
        steer.subVectors(steer, target);
        steer.multiplyScalar(1 / this.position.distanceToSquared(target));
        return steer;
    };

    Boid.prototype.avoidObj = function(obj){
        let raycaster = new THREE.Raycaster(this.position, this.velocity);
        let steer = new THREE.Vector3();
        if(raycaster.intersectObject(obj).length > 0){
            let center = obj.geometry.boundingSphere.center;
            let radius = obj.geometry.boundingSphere.radius;

            let u = new THREE.Vector3();
            u.subVectors(center, this.position);
            u.normalize();

            let vi = new THREE.Vector3();
            vi.copy(u);
            vi.multiplyScalar(this.velocity.dot(u));

            let t = (this.position.distanceTo(center) - radius) / vi.length();

            let vt = new THREE.Vector3();
            vt.subVectors(this.velocity, vi);

            let vtLen = vt.length();
            steer = vt.normalize().multiplyScalar(2 * (radius - t * vtLen));
            //a.multiplyScalar(10);

//            let len = a.length();
//            if (len > MAX_STEER_FORCE) {
//                a.divideScalar(len / (3 * MAX_STEER_FORCE));
//            }
            //console.log(steer);

        }
        return steer;
    }
</script>

<script>
    const WIDTH = window.innerWidth,
          HEIGHT = window.innerHeight,
          VIEW_ANGLE = 75,
          ASPECT = WIDTH / HEIGHT,
          NEAR = 1,
          FAR = 10000;
    const BOIDS_NUM = 100;

    let scene, camera, renderer;
    let cameraControls, stats;
    let boids = [], birds = [];
    let boid, bird;
    let boid_predator, predator;
    let cylinder;

    init();
    animate();

    function init() {
        let container = document.getElementById('canvas');

        //renderer
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(WIDTH, HEIGHT);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        //scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        //camera
        camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
        camera.position.set(0, 0, 500);

        //camera control
        cameraControls = new THREE.OrbitControls(camera, renderer.domElement);
        cameraControls.target.set(0, 0, 0); //the center of the orbit
        cameraControls.maxDistance = 500;
        cameraControls.minDistance = 10;
        cameraControls.update();

        //performance monitor
        stats = new Stats();
        container.appendChild(stats.dom);

        //add obstacle
        let geometry = new THREE.CylinderBufferGeometry( 30, 30, 60, 32 );
        let material = new THREE.MeshPhongMaterial(
            { color: 0x156289,
              emissive: 0x072534,
              flatShading: true}
              //side: THREE.DoubleSide}
        );
        cylinder = new THREE.Mesh( geometry, material );
        cylinder.geometry.computeBoundingSphere();
        scene.add( cylinder );

        //generate boids and birds
        geometry = new Bird();
        material = new THREE.MeshBasicMaterial({color: Math.random() * 0xffffff, side: THREE.DoubleSide});
        for (let i = 0; i < BOIDS_NUM; ++i) {
            boids[i] = new Boid();
            boids[i].position.set(200, Math.random() * 200 - 100, Math.random() * 200 - 100);
            boids[i].velocity.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);

            birds[i] = new THREE.Mesh(geometry, material);
            birds[i].phase = Math.floor(Math.random() * 62.83);
            scene.add(birds[i]);
        }

        boid_predator = new Boid();
        boid_predator.position.set(0, 100, 0);
        boid_predator.velocity.set(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
        predator = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color: 0xff0000, side: THREE.DoubleSide}));
        scene.add(predator);
    }

    function animate() {
        requestAnimationFrame(animate);
        render();
        stats.update();
    }

    function render() {
        for (let i = 0; i < BOIDS_NUM; ++i) {
            boid = boids[i];
            bird = birds[i];

            boid.move(boids, cylinder, boid_predator.position);
            bird.position.copy(boid.position);

            let color = bird.material.color;
            color.r = color.g = color.b = ( 500 - bird.position.z ) / 1000;
            bird.rotation.y = Math.atan2(-boid.velocity.z, boid.velocity.x);
            bird.rotation.z = Math.asin(boid.velocity.y / boid.velocity.length());
            bird.phase = ( bird.phase + ( Math.max(0, bird.rotation.z) + 0.1 )  ) % 62.83;
            bird.geometry.vertices[5].y = bird.geometry.vertices[4].y = Math.sin(bird.phase) * 5;
            bird.geometry.verticesNeedUpdate = true;
        }

        //boid_predator.position.add(boid_predator.velocity);
        predator.position.copy(boid_predator.position);
        predator.geometry.vertices[5].y = predator.geometry.vertices[4].y = Math.sin(birds[0].phase) * 5;
        predator.geometry.verticesNeedUpdate = true;

        renderer.render(scene, camera);
    }

</script>

</body>
</html>